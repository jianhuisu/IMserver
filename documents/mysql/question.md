## 常见MySQL面试题

数据预热
冷热分离

##### 分库分表之后，id主键如何处理？

A、单库生成自增 id
B、设置数据库 sequence 或者表自增字段步长
C、UUID
D、snowflake 算法

A、B、C 也是理论可行的，但是都各自有缺点，最好用 snowflake 算法。

snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，
用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。

1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。 41 bit：
表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2^41 - 1 个毫秒值，换算成年就是表示69年的时间。 
10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10台机器上哪，也就是1024台机器。
但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。
意思就是最多代表 2^5个机房（32个机房），每个机房里可以代表 2^5 个机器（32台机器）。
 12 bit：这个是用来记录同一个毫秒内产生的不同 id，12 bit 可以代表的最大正整数是 2^12 - 1 = 4096，
 也就是说可以用这个 12 bit 代表的数字来区分同一个毫秒内的 4096 个不同的 id。


##### 为什么InnoDB表要建议用自增列做主键？

使用自增列(INT/BIGINT类型)做主键，这时候写入顺序是自增的，和B+数叶子节点分裂顺序一致； 
该表不指定自增列做主键，同时也没有可以被选为主键的唯一索引(上面的条件)，

这时候InnoDB会选择内置的ROWID作为主键，写入顺序和ROWID增长顺序一致； 
除此以外，如果一个InnoDB表又没有显示主键，又有可以被选择为主键的唯一索引，
但该唯一索引可能不是递增关系时(例如字符串、UUID、多字段联合唯一索引的情况)，
该表的存取效率就会比较差

##### mysql数据库中innodb和myisam引擎的区别

区别主要在数据和索引的存储结构和存储方式上，以及对于事务的支持。

##### 百万级别或以上的数据如何删除

关于索引：由于索引需要额外的维护成本，因为索引文件是单独存在的文件,所以当我们对数据的增加,修改,删除,都会产生额外的对索引文件的操作,
这些操作需要消耗额外的IO,会降低增/改/删的执行效率。所以，在我们删除数据库百万级别数据的时候，

可以先删除字段的索引,然后删除其中无用数据。

或者分批删除.

##### 超大分页如何处理

首先我们要知道为什么超大分页会很慢 利用覆盖索引 直接获取到id，然后用 id in 操作
这样表述 不完全正确》》》》

首先了解查询语句的执行流程？？？？

 1. FORM: 对FROM左边的表和右边的表计算笛卡尔积，产生虚表VT1。
 1. ON: 对虚表VT1进行ON过滤，只有那些符合的行才会被记录在虚表VT2中。
 1. JOIN： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3。
 1. WHERE： 对虚拟表VT3进行WHERE条件过滤。只有符合的记录才会被插入到虚拟表VT4中。
 1. GROUP BY: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5。
 1. HAVING： 对虚拟表VT5应用having过滤，只有符合的记录才会被 插入到虚拟表VT6中。
 1. SELECT： 执行select操作，选择指定的列，插入到虚拟表VT7中。
 1. DISTINCT： 对VT7中的记录进行去重。产生虚拟表VT8.
 1. ORDER BY: 将虚拟表VT8中的记录按照<order_by_list>进行排序操作，产生虚拟表VT9.

类似于`select * from table where age > 20 limit 1000000,10`这种查询. 
这条语句需要`load1000000`数据然后基本上全部丢弃,只取`10`条.
当然比较慢. 我们可以修改为`select * from table where id in (select id from table where age > 20 limit 1000000,10)`.
这样虽然也`load`了一百万的数据,但是由于`索引覆盖`,要查询的所有字段都在索引中,所以速度会很快. 同时如果ID连续的好,
我们还可以`select * from table where id > 1000000 limit 10`,效率也是不错的.
(将数据从硬盘分批读取到内存进行过滤，最后合并筛选结果，这个操作是很影响性能的，因为需要将查询涉及到的所有数据从磁盘中读到内存,
**从磁盘取数据是最影响性能的**)

 - 利用延迟关联或者子查询优化超多分页场景,**优化的手段有许多种,但是核心思想都一样,就是减少load的数据**.
 - 合理利用缓存
 - 从需求的角度减少这种请求

##### 关心过业务系统里面的sql耗时吗？统计过慢查询吗？对慢查询都怎么优化过？

Yii框架提供的debug平台有多系统耗时的监控.
慢查询需要在mysql的控制台中进行查看是否开启,然后在慢查询日志中查看详细sql信息.

    // 临时开启慢查询 服务器reboot 或者 重新set该值 结束.
    mysql> show variables like "%slow_query_log%";
    +---------------------+--------------------------------------+
    | Variable_name       | Value                                |
    +---------------------+--------------------------------------+
    | slow_query_log      | OFF                                  |
    | slow_query_log_file | /var/lib/mysql/ff2a763d8dfd-slow.log |
    +---------------------+--------------------------------------+
    2 rows in set (0.00 sec)
    
    mysql> set GLOBAL slow_query_log = on;
    Query OK, 0 rows affected (0.00 sec)
    
    mysql> show variables like "%slow_query_log%";
    +---------------------+--------------------------------------+
    | Variable_name       | Value                                |
    +---------------------+--------------------------------------+
    | slow_query_log      | ON                                   |
    | slow_query_log_file | /var/lib/mysql/ff2a763d8dfd-slow.log |
    +---------------------+--------------------------------------+
    2 rows in set (0.01 sec)


##### 大表怎么优化？某个表有近千万数据，CRUD比较慢，如何优化？

核心思路

 - 大表变小表
 - 缓存(一次计算 多次使用)

单表记录数过大时，一些常见的优化措施如下：

 - 通过分库分表的方式进行优化，主要有垂直分表和水平分表
 - 缓存： 使用MySQL的查询缓存，另外对重量级、更新少的数据可以在应用层面进行缓存;
 - 读/写分离： 经典的数据库拆分方案，主库负责写，从库负责读；
 - 限定数据的范围： 务必禁止不带任何限制数据范围条件的查询语句(使用where条件)
 

##### 分库分表了是怎么做的？分表分库了有什么问题？
    
 - 水平拆分: 保持数据表结构不变，**通过某种策略存储数据分片(例如取模hash确定表名)**。
   这样每一片数据分散到不同的表或者库中，达到了分布式的目的。水平拆分可以支撑非常大的数据量。(一个表变多个表,表之间结构相同)
 - 垂直拆分: 根据数据列的使用频繁程度进行拆分,(一个表变多个表,表之间结构不一样)

垂直拆分
 
 - 垂直拆分的优点： 可以使得行数据变小，在查询时减少读取的Block数，减少I/O次数。此外，垂直分区可以简化表的结构，易于维护。
 - 垂直拆分的缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决。此外，垂直分区会让事务变得更加复杂；

水平拆分

分表仅仅是解决了单一表数据过大的问题，如果目的是提升MySQL并发能力，但由于表的数据还是在同一台机器上,IO瓶颈还是没有德到解决.那么水平拆分最好分库.
水平拆分能够,支持非常大的数据量存储，应用端改造也少，但**分片事务难以解决 ，分片数据Join性能较差，逻辑复杂**。

尽量不要对数据进行分片，因为拆分会带来逻辑、部署、运维的各种复杂度 ，**一般的数据表在优化得当的情况下支撑千万以下的数据量是没有太大问题的**。
**如果实在要分片，尽量选择客户端分片架构**，这样可以减少一次和中间件的网络I/O.

数据库分片的两种常见方案：

 - 客户端代理： 分片逻辑在应用层，比如说在开发框架里实现分片逻辑.
 - 中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中.应用层向调用单机一样调用中间件

##### 有用到中间件么？他们的原理知道么？

##### MySQL数据库cpu飙升到500%的话他怎么处理？

1  先用操作系统命令 top 命令观察是不是 mysqld 占用导致的
2  `show processlist`，看看里面跑的`session`情况，是不是有消耗资源的`sql`在运行。找出消耗高的`sql`
3  根据session情况,分析是因为单个sql导致负载太高,还是连接数太多导致负载过高.然后制定相关措施

#### 读写分离如何实现

两种方案 

    从应用层实现读写分离,使用分布式事务支持.
    从代理层实现读写分离,使用中间件 mysql-proxy 代理

读写分离的基础是主从复制.


##### 字段为什么要求定义为not null？

`null`值会占用更多的字节，且会在程序中造成很多与预期不符的情况。
在mysql中，含有空值的列很难进行查询优化，因为它们使得索引、索引的统计信息以及比较运算更加复杂。你应该用0、一个特殊的值或者一个空串代替空值

##### 如果要存储用户的密码散列，应该使用什么字段进行存储？

密码散列，盐，用户身份证号等固定长度的字符串应该使用char而不是varchar来存储，这样可以节省空间且提高检索效率。

##### 分库分表之后，id 主键如何处理？

A、单库生成自增 id
B、设置数据库 sequence 或者表自增字段步长
C、UUID
D、snowflake 算法
参考答案：A,B,C,D

答案解析：

snowflake 算法

A、B、C 也是理论可行的，但是都各自有缺点，最好用snowflake 算法。

snowflake 算法是 twitter 开源的分布式 id 生成算法，采用 Scala 语言实现，是把一个 64 位的 long 型的 id，1 个 bit 是不用的，
用其中的 41 bit 作为毫秒数，用 10 bit 作为工作机器 id，12 bit 作为序列号。

 1 bit：不用，为啥呢？因为二进制里第一个 bit 为如果是 1，那么都是负数，但是我们生成的 id 都是正数，所以第一个 bit 统一都是 0。
 41 bit：表示的是时间戳，单位是毫秒。41 bit 可以表示的数字多达 2^41 - 1，也就是可以标识 2^41 - 1 个毫秒值，换算成年就是表示69年的时间。 
 10 bit：记录工作机器 id，代表的是这个服务最多可以部署在 2^10台机器上哪，也就是1024台机器。
 但是 10 bit 里 5 个 bit 代表机房 id，5 个 bit 代表机器 id。
 意思就是最多代表 2^5个机房（32个机房），每个机房里可以代表 2^5 个机器（32台机器）。 
 12 bit：这个是用来记录同一个毫秒内产生的不同 id，12 bit 可以代表的最大正整数是 2^12 - 1 = 4096，
 也就是说可以用这个 12 bit 代表的数字来区分同一个毫秒内的 4096 个不同的 id。