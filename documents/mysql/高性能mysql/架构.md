## 第一章 架构

![](.source_images/f6f3e061.png)

 - 存储引擎不会解析SQL
 - 不同的存储引擎之间无法相互通信
 - 解析SQL发色和嗯在第二层
 - 事务，或者 根据主键提取记录 这种操作发生在存储引擎中，服务器层不管理事务
 
 
 
#### 连接管理 线程模型

每个客户端连接都会在服务端拥有一个线程，（至少拥有一个线程，有的客户端没有使用单例模式时 可能同一个客户端拥有多个连接实例）
服务端会对这些线程进行缓存，复用（即线程池）
达到使用少量线程来服务大量的客户端连接的目的.

也就是说 一个web站点可能同时有50000个用户并发访问，但是可能只有10-15个并发请求到MySQL服务器。

todo 连接池 与 持久连接的 区别

#### 优化与执行

查询顺序

1 接到客户端请求
2 查看查询缓存中是否有对应的查询结果，如果有 立刻返回 不在进行 sql解析 优化
3 如果没有 则对sql进行解析， 优化

#### 并发控制


多进程同时读写一个文件时，来自不同进程的数据可能会混杂在一起.
解决这类经典问题的方法就是并发控制

在处理并发读或者并发写时,通过实现一个由两种类型的的锁组成的锁系统来解决问题.
这两种类型的锁通称被称为 

 - 共享锁  别名： 读锁
 - 排它锁  别名： 写锁
 
锁的特性

 - 读锁是共享的，允许其它读锁在同一时刻共同读取同一个资源
 - 写锁是排它的，会阻塞其它的写锁或者读锁 

在数据库种，每时每刻都在发生锁定.

#### 锁粒度

锁粒度的大小决定系统的并发性能的高低,尽量精确锁定需要修改的部分,而不是全部数据可以带来更好的并发控制.
但是维护锁也会带来系统开销.所以 所谓的锁策略就是在锁开销与数据的安全性之间寻求一个平衡.

 - table lock   
 - row lock      并发性更好，但是锁开销更大.
 
#### 存储引擎

innodb在新版本中是默认的存储引擎
（因为myisam引擎不支持事务，不支持崩溃后的安全恢复，只有在少量写，数据量较小，可以忍受崩溃后部分数据丢失场景下使用）。
innodb使用MVCC来支持高并发.
innodb表是基于聚簇索引创建的
innodb真正支持热备份

innodb因为使用MVCC的并发处理架构,所以不能提供精确的数据行数统计信息.

如果在一个事务中需要操作的数据量比较大的话，我们可以考虑将数据分批，
避免大事务产生过多的undo

因为表压缩时采用的是哈夫曼算法,所以压缩后的表是只读的.

myisam

![](.source_images/e2673c46.png)
myisam最典型的性能问题还是表锁的问题
myisam的索引文件 与 数据文件 是分开存储的

myisam压缩表

如果只读，不更改，那么可以设置为压缩表，可以提升IO性能以及减少磁盘空间占用

人们经常会混淆 mermory 表 与 临时表 

 - 临时表指使用 create temporay table 创建的表，它可以使用任何存储引擎
 只在单个连接中可见，连接断开时 ，临时表销毁
 - memory 是表的存储引擎 数据全部存储在内存中 


排序 随机IO 顺序IO

当操作系统没有足够的内存而将一些虚拟内存写入到磁盘就会发生内存交换.
内存交换对mysql的影响是巨大的.
缺乏虚拟内存时将会导致MySQL崩溃
当交换空间溢出时,甚至整个Linux内核都会hang住


#### 事务

在同一个事务中使用多个存储引擎是不可靠的
要避免事务嵌套

MVCC 

innodb下的四种操作

    insert
    select
    update
    delete
    
MVCC 只在  repeatable read与 read commited 两种隔离级别下有效.

#### 索引可以带来的好处

 - 大大减少查找数据时需要扫描的数据量
 - 索引可以帮助服务器避免排序与临时表
 - 将随机IO变为顺序IO  B+存储索引key时,按序存储，当进行范围查找时,非常合适，并且需要对索引进行排序时,效率也是非常高的 (因为索引天然有序)
 
评价索引的三星系统

 - 索引将相关数据聚合到一起
 - 索引中数据的存储顺序与将要查找的排列顺序一致 
 - 覆盖索引
     
     
高性能索引策略

1 对索引列进行运算 
2 当索引列特特别长时,可以选择 模拟hash索引/前缀索引 来提升效率 前缀的选择性
3 某些情况下 多列索引 优于  单列索引


 - 避免随机IO 
 - 避免排序
 
将选择性更高的排列在前面
尽可能将需要做范围查找的列放在后面，例如查找年龄在 18-25岁的人
有的时候 age in (1,2,3) 比age<4 更容易使 最做前缀生效

为什么要有最左前缀限制?

![](.source_images/5f20ac60.png)

数据库的设计就是那样的，如果我们想提升数据库的性能，就要充分利用他的优点，避免它的缺点 

 - mysql的使用者 扬长避短 君子性非异也 善假与物也
 - mysql的开发者 对底层扬长避短 充分利用
 

 - 聚簇索引的最大优势是提高了IO密集型应用的性能(降低了IO次数)，但是如果数据全部都在内存中，那么聚簇索引的优势就变小了.
 - innodb二级索引需要进行两次索引查找，而不是一次（第一次从二级索引叶子结点上找到主键值 ，第二次从主键索引上找到数据行）
 - ？ 自适应hash
 
这里我就得说一下一个常见问题了，为什么 不要使用`select *`了，其中一个重要得原因就是这样基本无法利用覆盖索引的优势.

![](.source_images/baf6d30e.png)
![](.source_images/b92942d7.png) 

应当考虑对哪些列建立索引？
where后面的列 ，order by 的列，group by 的列

mysql有两种方式生成有序的结果 

 - 排序操作  Extra: filesort 
 - 按照索引顺序扫描  （需要满足一定特殊条件）

 
todo  覆盖索引的查询流程
https://www.cnblogs.com/starry-skys/p/12921641.html  最左前缀

联合索引的查询流程