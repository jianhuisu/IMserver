## SQL优化

### 创建时优化

### 维护时优化

1 如何定位及优化SQL语句的性能问题  explain/ slow_query_log
2 分析性能瓶颈原因  
3 制定解决方案   SQL性能优化的目标：至少要达到 range 级别，要求是ref级别，如果可以是const最好

##### 优化查询过程中的数据访问

 - 精简访问数据,只检索需要的数据,(select 列名 取代 select * / limit 数据量)
 - 重复查询相同的数据。解决办法：可以缓存数据，下次直接读取缓存
 - 使用索引覆盖扫描，权衡把查询的列都放到索引中，这样存储引擎不需要回表获取对应行就可以返回结果。
 - 改变数据库和表的结构，修改数据表范式.
 - 重写SQL语句，让优化器可以以更优的方式执行查询.

##### 优化长难的查询语句

 - **在应用层做关联更容易对数据库进行拆分**。查询效率会有大幅提升.
 - 将一个大的查询分为多个小的相同的查询.eg:一次性删除1000万的数据要比一次删除1万，暂停一会的方案更加损耗服务器开销.
 - 分解关联查询，让缓存的效率更高.
 - 执行单个查询可以减少锁的竞争.
 
##### 优化特定类型的查询语句

 - count(*)会忽略所有的列，直接统计所有列数，不要使用count(列名), (MyISAM单独维护了一个计数器)
 - 增加汇总表
 - 使用缓存
 - 优化关联查询
 - 确保使用索引且索引生效.
 - 确保`GROUP BY`和`ORDER BY`只有一个表中的列，这样MySQL才有可能使用索引。

##### 优化子查询

 - 用关联查询替代子查询
 - 优化GROUP BY和DISTINCT,这两种查询据可以使用索引来优化，是最有效的优化方法.关联查询中，使用标识列分组的效率更高.
   如果不需要ORDER BY，进行GROUP BY时加ORDER BY NULL，MySQL不会再进行文件排序。
 - WITH ROLLUP超级聚合，可以挪到应用程序处理
 - 优化LIMIT分页,LIMIT偏移量大的时候，查询效率较低.可以记录上次查询的最大ID，下次查询时直接根据该ID来查询
 - 优化UNION查询,UNION ALL的效率高于UNION

##### 优化WHERE子句

先说明如何定位低效SQL语句，然后根据SQL语句可能低效的原因做排查，

 1. 先从索引着手，
 1. 如果索引没有问题，考虑以下几个方面，数据访问(data load)的问题，长难查询句的问题还是一些特定类型优化的问题
 
some tips : 

    对SQL进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引
    应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描
    应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描
    应尽量避免在 where 子句中使用!=或<>操作符，否则引擎将放弃使用索引而进行全表扫描
    应尽量避免在 where 子句中使用or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描
    in 和 not in 也要慎用，否则会导致全表扫描,对于连续的数值，能用 between 就不要用 in
    如果在 where 子句中使用参数，也会导致全表扫描。`select id from t where num=@num`
    应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：
    不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
