## swoole

swoole的协程模型与go的协程模型不同 不论协程的调度 还是多核的利用上,要注意区别

 - go 协程抢占式调度
 - swoole 协程非抢占式调用 

Swoole中的网络请求处理是基于事件的，并且充分利用了底层的`epoll / kqueue`实现，使得为数百万个请求提供服务变得非常容易。

查看安装的swoole版本

    [sujianhui@dev0529 ~]$>php -r "echo SWOOLE_VERSION;"
    4.5.2

swoole快速启动中的例子大部分都是异步风格的编程模式，用协程风格(就是用协程同样可以实现相同的功能)。
协程使得原有的异步逻辑同步化，但是在协程的切换是隐式发生的，所以在协程切换的前后不能保证全局变量以及`static`变量的一致性。

    快速启动
        TCP服务器
        UDP服务器
        HTTP服务器
        WebSocket服务器
        MQTT(物联网)服务器
        执行异步任务(Task)
        协程初探
        
原文地址https://wiki.swoole.com/#/start/start_server

##### 什么是协程（纯用户态的线程）

协程可以简单理解为线程，只不过这个线程是纯用户态的，不需要操作系统参与，创建销毁和切换的成本非常低，
和线程不同的是swoole协程没法利用多核`cpu`的，想利用多核`cpu`需要依赖`Swoole`的多进程模型。(go的协程模型可以利用多核CPU)

 - 协程是一种用户态的线程 
 - 一个线程可以有多个协程 
 - 一个进程可以有多个协程  
 - swoole协程主要依赖于 c 的 setjmp longjmp (类似于 goto )的实现

`channel`可以理解为消息队列，只不过是协程间的消息队列，多个协程通过 `push` 和 `pop` 操作生产消息和消费消息，用来协程之间的通讯。
注意: **`channel` 是没法跨进程的，只有同一个`Swoole`进程里的协程才能同通讯**.

##### swoole 协程调度

用户的每个请求都会创建一个协程，请求结束后协程结束，如果同时有成千上万的并发请求，**某一时刻某个进程内部会存在成千上万的协程**.
大家知道多线程是为了提高程序的并发，同样的多协程也是为了提高并发。

swoole的协程是同步的,但是同时它也是非阻塞的.

 1. 协程代码段中发现代码遇到了，`Co::sleep()` 或者产生了`网络IO`,例如`MySQL->query()`,`Swoole`就会把这个`Mysql`连接的`Fd`放到 `EventLoop` 中
 1. 协程主动出让CPU给其它协程使用.`yield`
 1. 等待`MySQL`数据返回后就继续执行这个协程,`resume`

eg. 

    go(function () {
        MySQL->query(); 
    });

协程的创建、切换、挂起、销毁全部为内存操作，消耗是非常低的,所以程序仅启动了一个1个进程，就可以并发处理大量请求。
程序的性能基本上与异步回调方式相同，但是代码完全是同步编写的.
