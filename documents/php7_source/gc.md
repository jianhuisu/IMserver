## php的内存管理

#### 变量的自动回收

引用计数

	变量的赋值只会增加引用次数,共享一个value
	引用次数=0 时 释放value

写时复制
	
	引用计数大于0的value发生写操作时进行分离,zval 独立的 ，但是zval.value是共享的
	
	$a = array(1); // zend_array(refcount=1)
	$b = $a;       // zend_array(refcount=2)
	$b[] = 2;      // a : zend_array(refcount=1)  , b : zend_array(refcount=1)
	


#### php7的垃圾回收机制

php5.3之前的gc,基于引用计数的垃圾回收机制 当变量容器的ref_count计数清0时，表示该变量容器就会被销毁，实现了内存回收。
但是php5.3版本之前的垃圾回收机制存在一个漏洞`循环引用引发的内存泄漏问题`

    $a = [1];
    $a[] = &$a;
    unset($a);
    
可以看到，`unset($a)`之后由于数组中有子元素指向`$a`，所以`refcount = 1`，此时是无法通过正常的`gc`机制回收的，
但是`$a`已经已经没有任何外部引用了，所以这种变量就是垃圾，垃圾回收器要处理的就是这种情况，这里明确两个准则：

 - 如果一个变量`value`的`refcount`减少到0， 那么此value可以被释放掉,属于变量的自动回收，不属于垃圾.
 - 如果一个变量value的refcount减少之后大于0，那么此zval还不能被释放，**此zval可能成为一个垃圾**

针对第一个情况`GC`不会处理，只有第二种情况`GC`才会将变量收集到垃圾检查缓冲区中.
另外变量是否加入垃圾检查`buffer`并不是根据`zval`的类型判断的，
而是与前面介绍的是否用到引用计数一样是通过`zval.u1.type_flag`记录的，只有包含`IS_TYPE_COLLECTABLE`的变量才会被GC收集。

PHP的`zval`大部分都是按值传递, 写时拷贝的值, 但是有俩个例外, 就是`对象`和`资源`, 他们永远都是按引用传递,

    <?php
        function dummy($array) {}
        $array = range(1, 100000);
        $b = &$array;
        dummy($array);
    ?>
    
当我们调用dummy的时候, 本来只是简单的一个传值就行的地方, 但是因为$array曾经引用赋值给了$b, 
所以导致$array变成了一个引用, 于是此处就会发生分离, 导致数组复制, 从而极大的拖慢性能, 这里有一个简单的测试:

从PHP7开始, 对于在zval的value字段中能保存下的值, 就不再对他们进行引用计数了, 而是在拷贝的时候直接赋值, 这样就省掉了大量的引用计数相关的操作, 这部分类型有:

    IS_LONG
    IS_DOUBLE
    
对于那种根本没有值, 只有类型的类型, 也不需要引用计数了:

    IS_NULL
    IS_FALSE
    IS_TRUE

##### 回收过程

如果当变量的refcount减少后大于0，PHP并不会立即进行对这个变量进行垃圾鉴定，而是放入一个缓冲buffer中，
等这个buffer满了以后(10000个值)再统一进行处理，加入buffer的是变量zend_value的zend_refcounted_h:
垃圾缓存区是一个双向链表，等到缓存区满了以后则启动垃圾检查过程：遍历缓存区，再对当前变量的所有成员进行遍历，
**然后把成员的refcount减1(如果成员还包含子成员则也进行递归遍历，其实就是深度优先的遍历)，**
最后再检查当前变量的引用，如果减为了0则为垃圾。
这个算法的原理很简单，垃圾是由于成员引用自身导致的，那么就对所有的成员减一遍引用，结果如果发现变量本身refcount变为了0则就表明其引用全部来自自身成员。

php7垃圾回收机制在引用计数机制基础上,增加了buffer垃圾收集器功能,解决循环引用计数导致的内存泄露问题.

##### 参考资料

https://github.com/pangudashu/php7-internal/blob/master/5/gc.md
https://learnku.com/articles/33451