## 面向对象面试题

##### 真题1 组合与继承的区别,如何选择两个方式

组合和继承是面向对象中两种代码复用的方式.

 - 组合 has-a
 - 继承 is-a

选择式组合优于继承.采用接口与组合的方式比采用继承的方式具有更好的可扩展性。除非两个类之间是"is-a"的关系.
比如原来的误区,为了实现重用父类中的方法,为了实现多态等等.

PHP、.NET、Java 只有单继承.C++可以多继承.PHP可以通过实现多个接口来间接实现多继承的目的.
子类是不能继承父类的私有`private`方法和变量的,也不能继承`final`关键字修饰的类、方法。


##### 真题2 抽象类与接口的区别

抽象类具有以下特点:

 1. 抽象类不能直接被实例化,它的意义在于被扩展.(有点师出同源的意思)
 1. 抽象类中定义的方法,子类继承时必须实现父类所有的抽象方法而不是其中的几个,除非子类同样声明为一个抽象类
 1. 抽象类中方法没有方法体.方法体的具体实现只能存在子类中.
 1. 当子类实现抽象类的方法时,这些方法的访问控制可以和父类中的一样,也可以有更高的可见性,但是不能有更低的可见性.
 1. 包含抽象方法的类必须是抽象类.**但是抽象类中不一定必须有抽象方法,它也可能是一个空类**.

eg. 

    // 这种方式是允许的 
    abstract class bod{
        abstract function ec();
        abstract function dc();
    }
    
    abstract class B extends bod {
        
    }

接口:可以指定某个类必须实现哪些方法,但不需要定义这些方法的具体内容。在这种情况下,可以通过 interface 关键字来定义一个接口,在接口中声明的方法都不能有方法体。

    interface a{
        public function ec();
    }

两者之间的主要区别

 1. 使用关键自不同 `extends` `implements`
 1. 接口中不可以定义数据成员属性.但是抽象类有数据成员属性.
 1. 接口没有构在函数,抽象类可以有构造函数.
 1. 接口中的方法都是public访问属性.而抽象类中可以使用 private、protected 或 public    
    
##### 真题3 重载与重写

父类与子类中存在相同签名的方法.我们称子类`覆盖/重写`父类的方法.
某些场景中,出于某些原因子类重写了父类中的某些方法,但同时也需要调用父类中的原始方法.

    class A {
        $appName = NULL;
        public function __construct(){
            $this->appName = "yii";
        }
    }
    
    class B extends A {
        $title = NULL;
        public function __construct(){
            $this->title = "foo";
            // 这里我们需要调用父类的构造函数来为$appName属性赋值
        }
    }
    
如何处理？难道需要我们重新声明一个`实现相同但是签名不同的方法`吗？答案是否定的.
`类名::父类中的方法名` 或 `parent::父类中的方法名` 即可.
但如果子类没有构造函数和析构函数而父类有构造函数和析构函数,那么子类实例化后反而会自动调用父类的构造函数和析构函数。

多态:当同一个操作作用在不同的对象的时候,会有不同的语义,从而会产生不同的结果。**一般而言,多态有两种实现方式:覆盖和重载.**
因为PHP是弱类型语言,所以PHP没有重载的概念.但是PHP可以通过将对象当作参数进行引用的方式间接实现重载.(参考策略模式).

##### 真题4 类中使用static关键字修饰的变量在什么时候分配空间.

静态变量属于类,在内存中只有一个拷贝,所有实例对象都共享类的静态变量.
**当静态变量所在的类被加载式,该静态变量就会被分配空间,即可以被访问**。静态变量可以通过`类名::静态属性名`进行访问。

实例变量属于对象,**当对象被创建后,实例变量才会被分配空间,才能被访问**.不同实例的实例变量在内存中存在多个拷贝,相互隔离.只能用`对象->实例变量`的方式来引用.


##### 真题5 类的延迟静态绑定

首先明确两个概念

 - 重写 当子类继承父类后，子类在内部定义了与父类内同名的方法(函数名/参数 完全一致,只有实现不同,访问修饰符可以不同),新定义的方法会覆盖父类中对应的方法，子类只能调用内部定义的新方法。
 - 重载 在一个类中可以定义多个有相同的方法名的方法,通过参数的类型或个数来区分它们.（在PHP中没有重载这个概念）

按照正常的思路,子类继承父类后,如果子类的属性或者方法与父类有重合的地方,那么继承后方法或者属性的最终值都应该优先以子类中的值为准.
	
	<?php
	class Animal {

		public $name = 'Hello Animal';
		public function report() {
	    		return $this->name;
		}
	}

	class Dog extends Animal{
		public $name = 'Hello Dog';
	}

	$a = new Dog();
	echo $a->report();  // 结果为 hello dog
	

再来看一个延迟静态绑定的例子:

	<?php

	class Animal {
	    static $name = 'Hello Animal';
	    public static function report() {
		return self::$name;
	    }

	    public static function report_1(){
		return static::$name;
	    }
	}

	class Dog extends Animal{
	    static $name = 'Hello Dog';
	}

	echo Dog::report();
	echo "\n";
	echo Dog::report_1();
	echo "\n";

	// 输出结果为 
	// Hello Animal
	// Hello Dog

 - self 通过作用域控制父类无法访问变量的最终值 
 - static 通过声明静态作用域强制在最终类中查找属性或方法的最终值

##### 真题6 什么是构造函数 析构函数

- 构造函数 当类被实例化的时候会自动调用.(所以调用类名::静态方法时不会触发构造函数) 
- 析构函数 当对象被销毁时自动执行/当对象不再被引用时,将调用析构函数

在 C++语言中,子类的构造函数会隐式地调用父类的无参数的构造函数。但是在PHP中,
**子类的构造函数不会隐式地去调用父类的构造函数,需要开发者通过`parent::__construct()`来显
式地去调用父类的构造函数。**当子类没有定义构造函数的时候,它会继承父类的构造函数,
但前提是父类的构造函数不能被定义为`private`。

默认情况下,系统仅释放对象属性所占用的内存,并不销毁在对象内部申请的资源(例
如,打开文件、创建数据库的连接等),而利用析构函数在使用一个对象之后执行代码来清
除这些在对象内部申请的资源(关闭文件、断开与数据库的连接)。


