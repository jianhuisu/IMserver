# 非对称密钥加密和数字签名的区别

网络安全的三个方面

 - 防篡改   给美女发信息通知她去302房间,结果房号被篡改为303.
 - 防窃听   不能让别人知道你们要在302约会.防止跟美女之间的悄悄话被别人窥探
 - 防破坏   电话被呼死你恶意打满,无法接收美女的约会电话.

那么相对应的 防御措施为

 - 提取信息摘要 即`数字签名`
 - 对要发送的数据进行加密，`非对称加密+对称加密`
 - 保障服务的高可用,熔断,限流.

许多人分不清非对称密钥加密和数字签名的区别，其实很好理解。两者的使用目的不同,所以实现逻辑不同.

 - 加密要求密文可以还原为明文.
 - 签名并不强强制要求签名可以还原为明文.
 - 整个非对称加密过程使用的都是接收方提供的秘钥. 发送端公钥加密,接收端私钥解密.
 - 整个数据签名和解密的过程用的都是发送方的密钥。

数字签名并不强制求将接收的密文还原成明文.我们在生成签名时可以使用不可逆的加密方式.数字签名的主要目的在于校验报文的明文部分是否被篡改.
而不是将敏感信息完全加密.

在构建签名原文时，我们需把参数按照字典（比如a,b,c）顺序排序，具体排序方法直接调php的sort()方法。
然后按照`key=value`的方式把所有参数和值拼接成字符串，多个参数直接以“&”符号隔开，再然后把`md5(key)`拼接在该签名原文的最后。
最后使用app secret + md5(key) 生成最终签名。看一个签名算法 很简单.
    
    <?php
    class PaasSignUtil
    {
        static $_apps = [];
    
        /**
         * 对参数进行签名
         * @param $param
         * @param $appId
         * @param $secret
         * @return mixed
         */
        public static function generateParams($param, $appId, $secret)
        {
            $param['signed_at'] = time();
            $param['app_id']    = $appId;
            $param['sign']      = self::sign($param, $secret);
            return $param;
        }
    
        public static function sign(array $arr, $secretKey)
        {
            // 去除因重复调用可能产生的sign字段
            unset($arr['sign']);
    
            ksort($arr);
            $str = '';
            foreach ($arr as $k => $v) {
                $str .= $k . $v;
            }
    
            $str = $secretKey . $str . $secretKey;
            return md5($str);
        }
    
    }

验签很简单，验签方按照上面的签名流程生成的签名与传过来的签名作对比,如果相等就验签成功，否则验签失败。

一个需要注意的地方是数字签名的有效性,如果签名一经颁发永久有效,肯定不符合规范,同时也失去了它存在的意义.
但是如果我们在生成签名时使用不可逆算法,例如`md5`是没有办法逆向的,那么如何验证签名的有效性呢？

答案就是 将生成签名时的时间戳随着签名明文传输. 只屏蔽secret.即可. 签名的作用是防止 篡改信息.
接收端延签时,需要将`时间戳`纳入签名字段保障签名的有效时间. 而不仅仅依靠明文中的`time()`来判定.


