## ZK实现分布式事务

上一章我们了解了zookeeper到底是什么，这一章重点来看zookeeper当初到底面临什么问题？而zookeeper又是如何解决这些问题的？

实际上zookeeper主要作用就是`解决分布式环境下的一致性问题`。那么解决这个问题到底有哪些难点呢？我们一步一步来阐述和推理这个过程。


### 分布式事务

分布式事务对于一致性的要求是强一致性，这里我们用到一个经典的例子：bob给smith转账。强一致性的要求一定是`bob减钱的同时smith加钱`。

单机环境下操作时序:

 1. 锁定Bob的账户  `成功`
 1. 锁定Smith的账户  `成功`
 1. 检查Bob账户是否有100块钱  `成功`
 1. Bob账户减去100块钱  `成功`
 1. Smith账户加上100块钱 `成功`
 1. 解锁Bob账户 `成功`
 1. 解锁Smith账户 `成功`

简单讲就是有关bob的减钱和smith的加钱都转同一个库来做，可以采用数据库的事务特性(binlog)轻松支持。保证bob给smith转账的安全性。
(数据库事务的执行实际上是先将执行操作写入binlog，等到最后通过一个commit指令将binlog的内容一次更新到表中，或者写到一半通过一个rollback指令将binlog中的内容回滚)

而分布式环境操作时序:

 1. 锁定Bob的账户  `成功`
 1. `通过网络`锁定Smith的账户  `成功`
 1. 检查Bob账户是否有100块钱  `成功`
 1. Bob账户减去100块钱  `成功`
 1. `通过网络`Smith账户加上100块钱 `成功`
 1. 解锁Bob账户 `成功`
 1. `通过网络`解锁Smith账户 `成功`


假设 

   - 应用服务器是A
   - bob端的数据库是B，
   - smith端的数据是C

 那么A服务实现一个转账功能，需要`B事务`成功提交 同时`C事务`成功提交。然而因为网络的影响，可能出现两种情况

 1. 如果bob扣款成功，而网络通知smith失败了，则会出现bob的钱减了，smith的钱没加
 2. 如果bob扣款不成功，而smith加钱成功了，则会出现smith钱增加了，但是bob的钱也没减少

这种不一致的问题困扰着大家。任意一边出错想要回滚另一边都不是简单的数据库回滚的事情（ 因为此时已经成功提交）.
而是需要`做业务的逆向操作`，而不同业务的逆操作都不同，导致复杂性增加。mysql基于著名的两阶段提交协议（2PC）实现了分布式事务。

但是**两阶段协议并没有解决问题，只是提高了成功的概率而已**，因为第二阶段同样存在上面的两种情况。注意最终状态是 多台机器的最终状态与逻辑上的状态并不完全一致.

 1. prepare阶段的问题能够完全避免
 2. 考虑commit阶段，任意一边出错想要回滚另一边都不是简单的数据库回滚的事情.
 3. 还有一种例外情况，即prepare阶段完成后A挂了，则B,C即进入不知所措的状态。

可以看出，在2PC中事务无法做到像单机一样安全，只不过降低了出问题的概率。
出现了3阶段提交协议。3阶段的主要改进是把2阶段的prepare再分为canCommit和preCommit两个阶段。3PC解决上边的例外情况,
但是当第三阶段故障则同样面临无法回滚的问题.所以3PC仍然只是降低了发生概率，并没有真正解决问题。
实际上如果引入3PC会多2n次网络交互，在量大时反而更加不安全

### XTS

工业界的对分布式事务的应用是如何呢？可以参考某宝的知名分布式框架XTS。

XTS本质上是2PC。XTS引入协调者A的server部分，实际上是一个大集群，以配置的方式接入各种需要分布式事务的业务，集群由专门的团队维护，保证其可用性和性能.

协调者A的client部分则通过发起方调用，

 1. prepare阶段时，先通过client将本次事务信息发送到server，落库，然后即时推送prepare请求到B和C，
 1. 当收到B,C的响应时把他们状态入库，如果正常，则做commit提交；否则会用定时任务去推送未完成的状态直到完成。

分析

 - 上文提到的prepare之后协调者A挂了这种情况，在server集群的保证下，几乎很少会发生。
 - 而上文提到的所有超时的情况，都可以通过定时任务推送拿到一个确定的状态而不是盲目的选择回滚或者提交。另外由于B和C都是集群，很少会发生多次请求过去无响应的情况。
 - 直到最后一种情况就是commit时B成功了C失败了，或者反过来B失败C成功，这种情况成为`悬挂事务`，最终`等待人工`来解决，据说每天都有几笔到几十笔。

无疑XTS作为2PC在工业界的应用，是相当了不起的设计，通过各种方式规避了各种可能的不一致性，在性能，效率等方面做到了平衡。


### TCC（Try/Confirm/Cancel）

业务补偿类型，其基本思想是对每一个业务操作做一个逆操作，一旦成功了，就做正向业务，一旦失败了就做业务的逆操作。通常在业务逻辑简单并且正逆操作清晰的时候用比较好。

查询补偿

典型的场景是向银行发送了转账请求未得到明确的成功失败返回码，此时先做业务结果的查询，根据结果做相应处理，比如查询结果成功，则置状态为成功，查询结果失败，则做相应的业务补偿，查询结果为未知，则继续查询。


### 消息事务及消息重试

事务消息及消息重试本质上都是将一些通用的事务交给消息中间件，通过消息中间件来保证消息的最终一致性。

事实上，消息事务解决了这类问题，即本地事务和消息应当有一致性，解决这个一致性比较麻烦，比如消息中间件和业务同时实现XA；或者采用一些更加复杂的方式，比如将消息表与业务表放同库，利用数据库的事务来保证一致性，而消息系统只需要轮训该消息表即可；当然，也有消息的二阶段提交+补偿的方式。消息事务解决了消息发起方，即生产者与消息中间件之间的一致性问题。

	try{
	    //数据库操作
	    //消息投递
	}catch(Exception e){
	    //回滚
	}

消息中间件与消费者之间的一致性问题则需要通过重试+幂等来解决。消息重试中主要考虑重试次数以及重试时间的阈值变化。

### 参考资料

https://blog.csdn.net/liweisnake/article/details/68942165
业务补偿类型 https://www.cnblogs.com/lanxiaoke/p/8321657.html  核心思想就是尽力去做 不保证绝对成功
