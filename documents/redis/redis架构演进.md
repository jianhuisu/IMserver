# redis 架构演进

### 架构演进简介

#### v1. 单机redis.

虽然redis有持久化功能,但是如果redis服务器宕机仍然会存在少量数据的损失.
另外如果由于硬盘故障,就算是有备份也仍然不可避免数据丢失.

#### v2. `主+备`集群

为了解决单机硬盘故障时的数据丢失问题.(注意不是服务宕机时未内存数据未回写磁盘导致的少量数据丢失问题).
架构演变为`主从模式`. 主从模式也就是主从复制.redis的数据库复制多个副本部署在不同的服务器上. 从而实现物理隔离.
如果其中一台服务器出现故障，也能快速迁移到其他服务器上提供服务.避免出现单点故障.

在主从模式下,我们还可以进行读写分离,从而分担主节点的压力，从库只读,提升缓存服务的性能.一个主数据库可以有多个从数据库.


#### v3. 哨兵+Redis集群

在前面讲的master/slave模式，在一个典型的一主多从的系统中，slave在整个体系中起到了数据冗余备份和读写分离的作用。
当master遇到异常终端后，需要从slave中选举一个新的master继续对外提供服务，这种机制在前面提到过N次，比如在zk中通过leader选举、kafka中可以基于zk的节点实现master选举。
所以在redis中也需要一种机制去实现master的决策，redis并没有提供自动master选举功能，而是需要借助一个哨兵来进行监控。
 
哨兵是一个特殊的redis实例,也就是说,`哨兵实质为一个单独的进程`,哨兵的作用就是监控Redis系统的运行状况，它的功能包括两个：

 1. 监控master和slave是否正常运行.
 2. master出现故障时自动将slave数据库升级为master

为了解决master选举问题，引入了哨兵,但这又引出了一个单点问题，也就是哨兵的可用性如何解决,在一个一主多从的Redis系统中，可以使用多个哨兵进行监控任务以保证系统足够稳定。
此时哨兵不仅会监控master和slave，同时还会互相监控；这种方式称为哨兵集群，哨兵集群需要解决故障发现、和master决策的协商机制问题.

哨兵通过长连接感知master/slave节点以及其它哨兵节点的健康状况.

#### v4. `redis cluster`

即使是使用哨兵，Redis集群的每个节点数据库存储集群中的所有数据，从而导致集群的总数据存储量受限于可用存储内存最小的节点，形成了木桶效应。
而因为Redis是基于内存存储的，所以这一个问题在redis中就显得尤为突出了.

针对上面的问题.在redis3.0之前，通过在客户端去做的分片，通过hash环的方式对key进行分片存储。将数据存储到不同的集群.
分片虽然能够解决各个节点的存储压力，但是维护成本高、增加、移除节点比较繁琐。

因此在redis3.0以后的版本最大的一个好处就是支持集群功能，集群的特点在于拥有和单机实例一样的性能，同时在网络分区以后能够提供一定的可访问性以及对主数据库故障恢复的支持。
 
一个Redis Cluster由多个Redis节点构成。不同节点组服务的数据没有交集，也就是每个一节点组对应数据sharding的一个分片。节点组内部分为主备两类节点，对应master和slave节点。两者数据准实时一致，通过异步化的主备复制机制来保证。一个节点组有且只有一个master节点，同时可以有0到多个slave节点，在这个节点组中只有master节点对用户提供写服务，读服务可以由master或者slave提供。 

redis-cluster是基于gossip协议实现的无中心化节点的集群，因为去中心化的架构不存在统一的配置中心，各个节点对整个集群状态的认知来自于节点之间的信息交互。在Redis Cluster,这个信息交互是通过Redis Cluster Bus来完成的。

redis使用一致性hash算法来保障增删节点高效.使用位图数据结构来实现去中心化.


### 参考资料

https://www.cnblogs.com/ivy-zheng/p/10884314.html