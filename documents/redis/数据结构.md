# 数据结构


string  => SDS
list    => 双向链表 + 头尾指针 + len 的结构持有链表.
set     => intset 或者 hashtable
zset    => 只有有序集合使用跳表实现.
hash    => 字典 



### 基石:SDS字符串

SDS与C字符串的区别

	struct sdshdr{
		int len;     // 已使用空间
		int free;    // 未使用空间
		char buf[];  // 字节数组
	}


 1 常数级别时间复杂度获取字符串长度
 2 杜绝缓冲区溢出(拼接字符串)
 3 减少字符串修改时带来的内存重新分配次数. 减少修改带来的系统调用次数. 更好的性能表现.
 4 二进制安全

### 链表 

 - 双端
 - 无环:链表头结点的前置节点以及表尾的后置节点为NULL,所以无环.
 - 自带头尾指针
 - 自带链表长度计数器
 - 多态. `（void *）`指针存储节点值 . dup/match/free 来控制节点值


结构体

	struct list  {

		listNode *head;
		listNode *tail;
		unsigned long len;
		void *(*dup)(void *ptr);
		void *(*free)(void *ptr);
		void *(*match)(void *ptr)

	}


### 字典/符号表(symbols)/关联数组/映射(map)/哈希表

是一种用于保存键值对的抽象数据结构.`key-value pair`.

redis数据类型的`hash键`就是保存在字典里面.

	>hlen website
	>hgetall website
	>hget website baidu

一个哈希表保存多个哈希表节点,每个哈希表节点保存字典中的一个键值对.

redis使用链地址法解决键冲突.被分配到同一个索引上的多个节点可以通过单向链表next指针连接起来.并且使用头插法.(复杂度为O(1))

 - 每个字典带有两个hash表,一个平时用，一个仅仅在rehash时使用.
 - 哈希表使用 链地址法解决键冲突 . 头插法
 - hash表的扩展与收缩,是渐进式rehash.

### 跳表

在redis内部使用并不广泛.只有有序集合底层使用跳表实现.

跳表的层高 log以跨度为低,长度的对数. (如果跨度固定的话).

zskiplist + zskipListNode 

跳表的节点按照分值有序排列. 跳表性能媲美平衡树.且实现简单.


### 整数集合

整数集合(intset)是集合键的底层实现之一.当一个集合中只包含整数值元素,并且这个集合的元素数量不多时,redis就会用整数集合来作为集合键的底层实现.

 - 自动去重.
 - 自动排序.
 - 升级降级操作节约内存. 整数集合不支持降级操作.


### 压缩列表

ziplist 

 - 当一个列表键只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度较短的字符串.
 - 当一个哈希键只包含少量列表项,并且每个列表项要么就是小整数值,要么就是长度较短的字符串.

压缩列表是为了节约内存而开发的.


###  对象

redis并没有直接只用上述的底层数据结构直接去实现键值对数据库，而是在此之上实现了对象系统.
把每一种类型看做一类对象来处理.

