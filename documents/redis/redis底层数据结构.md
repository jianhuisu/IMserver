## redis底层数据结构

Reids并没有直接使用这些数据结构来构建键值对数据库,
而是基于这些数据结构又封装了一层 对象层. 便于灵活适配各种应用场景.

#### 链表

Redis的开发语言C中没有内置这种数据结构,所以redis自己构建了链表实现,redis中链表有以下特点

 1. 是双向链表，寻找直接前驱与直接后继的时间复杂度为O(1)
 1. 无环  如果指向 前驱或者后继的指针为NULL，代表链表到头了
 1. 链表带有头指针 还有尾指针，所以链表获取 头结点 或者 尾结点 的 时间复杂度为O(1)
 1. 链表带有长度计数器 ，获取链表长度的 时间复杂度为O(1)
 1. 多态： 链表的结点使用 void* 来保存结点的值,链表可以保存各种不同类型的值 （有点像php的zval了）
 
使用场景：用来实现 列表键 (list)，发布订阅 publish， 
 
####  字典 

字典/符号表/关联数组/映射
Redis的开发语言C中没有内置这种数据结构,所以redis自己构建了字典实现
特点

 1. redis采用MurmurHash2算法计算hash值
 1. 扩展收缩是 渐进式的 并不是一次性完成
 1. 使用拉链法解决hash冲突

使用场景 ： 用来实现 哈希键 / 数据库 

#### 跳跃表

Redis的开发语言C中没有内置这种数据结构,所以redis自己构建了跳跃表实现

在大部分情况下 跳跃表的效率可以跟平衡树相媲美，并且实现更为简单，所以 有很多程序使用跳跃表来代替 平衡树 

 - 跳跃表是一种有序数据结构  表中的结点按照分值大小进行排序,分值相同时,按照成员对象的大小进行排序. 
 - 跳跃表的查找操作的平均复杂度为 O(logN) 最坏为 O(N)
 - 跳跃表的实现由 zskiplist + zskiplistNode 两个结构组成 
 - 每个跳跃表结点的层高都是`1- 32`之间的随机数
 - 同一个跳跃表中 多个结点可以包含相同的分值 但是每个结点的成员对象 必须是唯一的
 - 跳跃表对区间输出的支持优于红黑树
 
使用场景： 实现 有序集合 zset

#### 整数集合

整数集合是集合键的底层实现之一. 适合集合只包含整数值元素，并且集合中元素数量步多时使用

    typedef struct intset{
        uint32_t encoding;
        uint32_t length;
        int8_t contents[];
    } 

 - intset通过自动升级 机制来节约内存 提升灵活性 ，只支持升级 不支持降级
 - 整数集合的底层实现为数组 这个数组以`有序` `无重复` 的方式保存集合元素. 在需要的事后可以根据新添加的元素类型改变数组的类型 
 
使用场景： 集合 set  

#### 压缩列表

压缩列表是 列表 list  与  hash表的底层实现之一. 在列表项比较少，并且项的长度比较短的时候，为了节省内存，而
设计的 顺序型数据结构.(类似于数组).

特点：
    
 - 压缩列表是为了节约内存而开发的顺序存储数据结构
 - 压缩列表可以包含多个结点，每个结点包含一个字节数组或者一个整型变量
 - 添加新结点到压缩列列表或者删除结点时，可能会引发连锁更新操作.但是概率非常低.