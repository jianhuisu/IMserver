## redis集群

redis的多机部署共有三种结构 

 - 类似于mysql主从结构 的主从复制模式  slaveof BGSAVE 全同步 / 差异同步
 - 基于 哨兵+主从复制的 高可用结构  , 通过哨兵实现 状态监控 重新选举 故障转移
 - redis cluster     也属于高可用结构  由工作节点自行实现监控 选举 故障转移  ， 数据分片存储 16384个slot

为什么会有三种方案: 

 - 主从复制是为了数据备份.
 - 哨兵是为了高可用，Redis主服务器挂了哨兵可以切换.
 - 集群则是因为单实例能力有限，搞多个实例分散存储压力. 
 
#### 基于`主从复制`架构的多机部署

类似于mysql的主从复制.
客户端使用 `slaveof` 命令,使服务端去复制 另外一个服务器数据.

 - master  被复制的服务器  
 - slave   需要复制别人数据的服务器
 
 在后台异步(Asynchronously)保存当前数据库的数据到磁盘。
 BGSAVE 命令执行之后立即返回 OK ，然后 Redis fork 出一个新子进程，原来的 Redis 进程(父进程)继续处理客户端请求，而子进程则负责将数据保存到磁盘，然后退出。
 
slaveof过程分析

 1. 客户端向`slave 服务器`发送`slaveof <master_ip> <master_port>`复制指令,
 1. `slave 服务器`接收到`slaveof`指令后,立刻向客户端返回一个`OK`响应,表示自己已经接收到复制任务.真正的复制工作将会在OK返回之后异步执行.
 1. `slave 服务器`发起到`master 服务器`的TCP链接.连接建立后进行身份验证(即slave有没有master的登陆密码),
 1. `slave`执行`REPLCONF listening-port <port>`,通知master slave监听端口(不过这个端口貌似没有什么卵用)
 1. `slave`向`master`发送`PSYNC`命令,执行同步操作.将自己的数据库更新至master当前的状态.
 1. 数据同步完成以后,`slave`,`master`进入命令传播阶段,`master`将自己的写命令传播到`slave`.(这个阶段 slave会以每秒一次的频率向主服务器发送心跳，防止掉线)

`PSYNC`过程分析

 - 完整重同步
 - 部分重同步
 - 复制积压缓冲区  固定长度的队列，例如保存1M的长度.根据自己的情况设置.
 - master复制偏移量  slave复制偏移量
 - PSYNC可以高效的处理断线重连后的数据恢复问题.**master通过向slave传播写命令来维持主从一致**.
     
步骤描述

 1. `slave`向`master`发送`PSYNC`命令,请求执行`完整重同步`操作.(因为第一次进行复制)
 1. `master`接收到`PSYNC`命令后, 后台执行`BGSAVE`命令,并立刻向`slave`返回`FULLRESYNC 53asdfasdfassdfasdfasdfasdfb3 10086`(即`同步类型 master-runid master复制偏移量`).
 1.  后台异步执行的`BGSAVE`命令`fork `一个新子进程，原来的Redis进程继续处理客户端请求，而子进程则负责将数据保存到磁盘，生成一个RDB文件.并将这一时间点之后的写操作写入到`复制积压缓冲区`中
 1. 当RDB制作完成后,发送到slave进行恢复.然后slave根据传播的命令补偿差异数据.**复制积压缓冲区中保存的是最近一段时间传播的写命令**.

注意:虽然BGSAVE不占用主进程的网络IO,但是会占用机器的CPU，磁盘IO,包括之后发送RDB时,也会占用主机的大量带宽.

#### 基于`哨兵+主从复制`架构的高可用多机部署

主从模式的弊端就是不具备高可用性，当master挂掉以后，Redis将不能再对外提供写入操作，因此sentinel应运而生。

sentinel也是一个redis实例,不过它是一个特殊的redis实例.
sentinel监听多个主服务器，sentinel会维护一个字典,存储自己监听的主服务器的状态.每10秒一次频率通过命令连接使用`info`命令探测.


    字典键             ： 字典值
    master_ip+port    ： master redis info命令的返回结果.
    
 - 哨兵与主服务器/从服务器 : 每10秒一次频率通过命令连接使用`info`命令探测.sentinel直接监控master的info,就可以间接的发现从服务器.故障转移时 频率提升到1次/1s
 - 哨兵与哨兵 ： Sentinel会以每两秒一次的频率 通过向被监测的主服务器的_sentinel::hello频道发送信息来通知其它哨兵，宣告自己的存在.
 - 所有实例： Sentinel会以每秒一次的频率向所有与它创建了命令连接的实例（主服务/从服务/其它哨兵）发送PING命令,**通过回复来判断是否在线**.


##### 主服务器判定为客观下线的条件：

 - 多个sentinel可能会监测同一个主服务器
 - 一个sentinel可能会同时监测多个主服务器
 - sentinel也会维护监测同一主服务器的其它sentinel的实例结构.
 - sentinel之间不会创建订阅连接,但是会创建命令连接.
 - 最终监测同一主服务器的多个sentinel将会形成相互连接的网络.

当Sentinel将一个主服务判定为主观下线时,它同样会向其它监控该主服务器的哨兵进行询问,看他们是否同意这个主服务器进入到主观下线状态.
(因为不同sentinel的主观判定规则不同,所以主观可能不同.),**只有当Sentinel收集到足够多的主观下线选票后,才会将主服务器判定为客观下线.
并发起一次针对主服务器的故障转移操作.**

##### 故障转移

当一个主服务器被判断为客观下线时,监视这个主服务器的各个sentinel将会进行协商,
选举出一个新的领导Sentinel.并且由领头的Sentinel执行故障转移.

故障转移过程

 - 选出新的主服务器
 - 修复从服务器的复制目标
 - 将旧的主服务器变为从服务器.

哨兵(Sentinel)：可以管理多个Redis服务器，它提供了监控，提醒以及自动的故障转移的功能。
复制(Replication)：则是负责让一个Redis服务器可以配备多个备份的服务器。
Redis正是利用这两个功能来保证Redis的高可用。

#### redis集群 redis cluster

Redis集群是Redis提供的分布式数据库方案.目的是为了解决单实例的存储容量限制.

1 redis.conf 开启 cluster
1 127.0.0.1:6379> cluster nodes  查看所在集群中有哪些结点.

重点：

 1.  各个结点通过握手来将其它结点添加到自己所在的集群.   cluster meets 
 2.  集群中一共分为16384个slot,slot可以分别指派给集群的各个结点，每个结点维护一个位数组来记录哪些slot分配了自己,哪些slot指派给了其它结点.
 3.  结点在接收到一个命令请求时，会首先检查这个命令请求锁钥处理的key所在的slot是否由自己负责,如果不是，返回MOVED错误引导客户端转向负责处理slot的结点.
 4.  对redis集群的重新分片工作是由 redis-trib 负责执行的.重新分片的关键是 将属于一个结点slot的所有键值对转移到另外一个结点.
 5.  如果结点A正在迁移slot_i 到结点B，那么当结点A没能在自己的数据库中找到命令指定的键时,结点A会向客户端返回一个ASK错误,指引客户端到结点B进行查询.
 6.  MOVED表示键不在当前结点，而ASK是临时性不在.
 7.  集群里面的从结点用于复制主节点数据,在主结点下线时,代替主结点继续处理命令请求.
 8.  集群中的结点通过发送和接收消息来进行通信.常见的消息 MEET PING PONG PUBLISH FAIL

##### 槽指派

只有16384个槽全部被指派完成时,集群才会处于上线状态.
否则处于下线不可用状态.

##### 重新分片 

由集群管理软件trib负责

##### 故障转移

当一个从结点发现自己复制的主结点进入了已下线状态时,从结点开始对主结点进行故障转移.

 1. 下线主结点的slave结点中，会有一个从结点被选中
 1. 被选中的从结点成为新的主节点，新的主节点撤销对已经下线的主结点的槽指派,并将这些槽指派给自己.
 1. 新的主结点向集群广播一个PONG信息,通知集群中的其它结点：这个从结点已经变为主结点，接管了原主节点负责处理的槽.
 1. 新的主节点开始接收和自己负责处理槽相关指令.

todo Redis Cluster故障转移时 会丢失数据吗
    
##### 重新选举

每个结点维护一个计数器.以便在重新选举时使用.
  
