# key命令

Redis中有一个经典的问题，在巨大的数据量的情况下，做类似于查找符合某种规则的Key的信息，这里就有两种方式，

 - keys命令，简单粗暴，由于Redis单线程这一特性，keys命令是以阻塞的方式执行的，keys是以遍历的方式实现的复杂度是 `O(n）`，Redis库中的key越多，查找实现代价越大，产生的阻塞时间越长。
 - scan命令，以非阻塞的方式实现key值的查找，绝大多数情况下是可以替代keys命令的，可选性更强. (类似于mysql的分页查找)

Example 

 - `127.0.0.1:6379> keys *name`
 - `127.0.0.1:6379> scan 0 match name* count 20`

scan的语法为：`SCAN cursor [MATCH pattern] [COUNT count] The default COUNT value is 10.`

SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数， 以此来延续之前的迭代过程。

scan在遍历key的时候，0就代表`cursor 0`，`name*`代表按照key1111开头的模式匹配，count 20中的20并不是代表输出符合条件的key，
而是限定服务器单次遍历的字典槽位数量(约等于)。

这个槽是不是Redis集群中的slot. 验证方式很简单,如果上面说的`字典槽`的数量是集群中的slot，又知道集群中的slot数量是16384,
那么遍历16384个槽之后，必然能遍历出来所有的key信息， 然后实验中当遍历的字典槽的数量`20000`的时候，游标依旧没有走完遍历结果，因此这个字典槽并不等于集群中的slot的概念.

scan命令是非阻塞的,如果它要实现search到count个key才能返回就势必称为阻塞操作.所以上边的count理解为一次迭代遍历多少个slot更为准确.
匹配到的key的数量理论上小于等于count值.

scan 指令是一系列指令，除了可以遍历所有的 key 之外，还可以对指定的容器集合进行遍历。

 - zscan 遍历 zset 集合元素，
 - hscan 遍历 hash 字典的元素、
 - sscan 遍历 set 集合的元素。 

SSCAN 命令、 HSCAN 命令和 ZSCAN 命令的第一个参数总是一个数据库键（某个指定的key）。
另外，使用`redis desktop manager`的时候，当刷新某个库的时候，控制台自动不断刷新scan命令.这就是刷新操作的由来了.

注意生产环境禁止使用`key *`. 这会阻塞主线程的正常业务. 
