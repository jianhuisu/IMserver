### php常见面试题

fpm slow log
view FPM status page

quick sort : sort()  self write ; use c write 


nginx load balance algho

垃圾回收机制 
neicun fen pei jizhi
卡特兰数

Zend引擎可以将源文件转换成二进制文件运行  => Zend引擎将源文件转换成opcode代码，然后在虚拟机上运行

解析域名->通过dns拿到IP->建立TCP连接->向服务器拿到请求->返回信息

外部排序指的是大文件的排序，即待排序的记录存储在外存储器上，待排序的文件无法一次装入内存，需要在内存和外部存储器之间进行多次数据交换，以达到排序整个文件的目的。外部排序最常用的算法是多路归并排序，即将原文件分解成多个能够一次性装人内存的部分，分别把每一部分调入内存完成排序。然后，对已经排序的子文件进行归并排序。 大规模数据存储中，实现索引查询这样一个实际背景下，树节点存储的元素数量是有限的（如果元素数量非常多的话，查找就退化成节点内部的线性查找了），这样导致二叉查找树结构由于树的深度过大而造成磁盘I/O读写过于频繁，进而导致查询效率低下，那么如何减少树的深度（当然是不能减少查询的数据量），一个基本的想法就是：采用多叉树结构（由于树节点元素数量是有限的，自然该节点的子树数量也就是有限的）。 这样我们就提出了一个新的查找树结构——多路查找树。根据平衡二叉树的启发，自然就想到平衡多路查找树结构，也就是B~tree(B树结构)。


fpm模式的生命周期

php内部扩展 外部扩展 
zend 的角色

定时器 

reference ?

    $a = 1;
    $b = &a;
    unset($b);


php trait
nginx 负载均衡算法

在表级锁锁定期间，其它进程无法对该表进行写操作，但可以执行读操作
行级锁在多线程中相比页级锁更不容易产生锁定冲突 、  表锁 行锁 是共享锁 还是独占锁


##### 奇偶校验位

请自我介绍一下?
 
   我叫苏建辉 有近五年的工作经验,大部分工作内容都与教育行业有关.
   主要涉及 线教育系统开发/办公系统系统开发,中间也穿插着做过论坛/内容管理系统/微信(小程序/公众号开发)等其他项目 
    
你是公司负责那些项目?

    直播小程序
    OA系统 在线数据分析系统|分校系统
    
接口安全方面是怎么处理的? 
    
    数据签名 signature

PHP restful    

##### 关于PHP-FPM子进程数量说法正确的有？

static ：表示在 php-fpm 运行时直接 fork 出 pm.max_chindren 个子进程，
dynamic：表示，运行时 fork 出 start_servers 个进程，随着负载的情况，动态的调整，最多不超过 max_children 个进程。
一般推荐用 static ，优点是不用动态的判断负载情况，提升性能；缺点是多占用些系统内存资源。

PHP-FPM 子进程数量，是不是越多越好？ 当然不是，pm.max_chindren，进程多了，增加进程管理的开销以及上下文切换的开销。更核心的是，能并发执行的 php-fpm 进程不会超过 cpu 个数。如何设置，取决于你的代码。如果代码是 CPU 计算密集型的，pm.max_chindren 不能超过 CPU 的内核数。如果不是，那么将 pm.max_chindren 的值大于 CPU 的内核数，是非常明智的。国外技术大拿给出适用于 dynamic 方式的公式： 在 N + 20% 和 M / m 之间。

N 是 CPU 内核数量。
M 是 PHP 能利用的内存数量。
m 是每个 PHP 进程平均使用的内存数量。
*static方式的公式：M / (m 1.2)**

当然，还有一种保险的方式，来配置 max_children。 先把 max_childnren 设置成一个比较大的值。稳定运行一段时间后，观察 php-fpm 的 status 里的 max active processes 是多少，然后把 max_children 配置比它大一些就可以了。

pm.max_requests：指的是每个子进程在处理了多少个请求数量之后就重启。这个参数，理论上可以随便设置，但是为了预防内存泄漏的风险，还是设置一个合理的数比较好。

##### 设计一个高并发系统，需要重点考虑的问题有？
  
A、系统拆分
B、缓存
C、MQ  可能你还是会出现高并发写的场景 大量的写请求灌入 MQ 里，排队慢慢玩儿，后边系统消费后慢慢写 控制在 mysql 承载范围之内
D、分库分表
E、读写分离
F、ElasticSearch   Elasticsearch，简称 es。es 是分布式的，可以随便扩容，分布式天然就可以支撑高并发，因为动不动就可以扩容加机器来扛更高的并发。那么一些比较简单的查询、统计类的操作，可以考虑用 es 来承载，还有一些全文搜索类的操作，也可以考虑用 es 来承载。


##### 消息队列常见的使用场景

    有很多，但是比较核心的有 3 个：解耦、异步、削峰

shell awk sed uniq sort count cat 的用法
正则的引擎表述错误的是?
get 与 post 的区别
    
    ！！！！GET产生一个TCP数据包；POST产生两个TCP数据包。
    
    长的说：
    对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
    而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
    
    也就是说，GET只需要汽车跑一趟就把货送到了，而POST得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。
    
    ！！！！GET在浏览器回退时是无害的，而POST会再次提交请求。
    GET产生的URL地址可以被Bookmark，而POST不可以。
    GET请求会被浏览器主动cache，而POST不会，除非手动设置。
    GET请求只能进行url编码，而POST支持多种编码方式。
    GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
    GET请求在URL中传送的参数是有长度限制的，而POST没有。
    对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
    GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
    GET参数通过URL传递，POST放在Request body中。
    
    

你使用过哪种PHP的模板引擎？
你遇到过哪些难题,如何解决的?
第三方登录 oauth
表单中get和post提交方式的区别
redis和memcacahe、mongoDB的区别？
静态化如何实现的？伪静态如何实现？
PHP7的新特性？重点
PHP支持多继承吗？
    
    不支持
    
常见的 PHP 安全性攻击 XSS / CSRF / 代买注入 / 做好用户输入过滤 SQL注入
 
在HTTP通讯过程中，是客户端还是服务端主动断开连接？
三次握手和四次挥手，以及他们每步的状态。 般都是有客户端告诉服务端，我这边东西发完了，可以断连接了么。但是如果客户端发完FIN服务端没有回复，就会重试，直到超过超时时间，就断了。服务端也一样，超过时间，服务端就断了。

38、有两个文件文件，大小都超过了1G，一行一条数据，每行数据不超过500字节，两文件中有一部分内容是完全相同的，请写代码找到相同的行，并写到新文件中。PHP最大允许内内为255M。
将文件拆分成若干个小文件，根据内容计算hash值，分散到不同文件。

请用SHELL统计5分钟内，nginx日志里访问最多的URL地址，对应的IP是哪些？
写一段shell脚本实现备份mysql指定库（如test)到指定文件夹并打包，并删除30天前的备份，然后将新的备份推送到远端服务器，完成后送邮件通知。

一些常见算法面试题

SSO登录
sku减库存的实现? SKU = Stock Keeping Unit (库存量单位)
 

CAS原理
说到单点登录，就肯定会见到这个名词：CAS （Central Authentication Service），下面说说CAS是怎么搞的。

##### php代码执行完毕后会自动执行垃圾回收，所以不需要手动执行垃圾回收

php一段代码有可能要长时间执行，但若此期间有未引用的变量的话，就会占用内存的空间，导致运行缓慢等问题

下面这三种说法是正确的

A、在一个垃圾周期中，通过检查引用计数是否减1，并且检查哪些变量容器的引用次数是零，来发现哪部分是垃圾
B、可以通过调用gc_enable() 和 gc_disable()函数来打开和关闭垃圾回收机制
C、通过清理未被使用的变量来节省内存的占用

##### 经常使用哪些设计模式

观察者模式  notify方法的实现 参考yii框架 事件机制实现原理  定义对象间一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知自动更新。
策略模式    定义一系列的算法，把他们一个个封装起来，并使他们可以互相替换，本模式使得算法可以独立于使用它们的客户。
组合模式    Composite使得用户对单个对象和组合对象的使用具有一致性。将对象组合成树形结构以表示部分整体的关系，
装饰器模式  是继承机制的替代解决方案，可以动态的增加额外属性
适配器模式  经纬度 极坐标的精度损失
工厂模式    动态加载 统一管理
单例模式    全局唯一配置


