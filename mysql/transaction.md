## Transaction

事务是逻辑上的一组操作，要么都执行，要么都不执行。

假如小明要给小红转账1000元，这个转账会涉及到两个关键操作就是：
    
 1. 将小明的余额减少1000元，
 1. 将小红的余额增加1000元。
 
万一在这两个操作之间突然出现错误比如银行系统崩溃，**导致小明余额减少而小红的余额没有增加**

 - 原子性（Atomicity）   原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。
 - 一致性（Consistency） 一致性表示事务完成后，符合逻辑运算
 - 隔离性（Isolation）   事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。
 - 持久性（Durability）  持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响

查询当前系统的事务隔离级别

    mysql> select @@tx_isolation;
    ERROR 1193 (HY000): Unknown system variable 'tx_isolation'
    mysql> select @@transaction_isolation;
    mysql> show variables like 'transaction_isolation';
    +-------------------------+
    | @@transaction_isolation |
    +-------------------------+
    | REPEATABLE-READ         |
    +-------------------------+
    1 row in set (0.00 sec)


四种事务隔离级别

 - 串行化    Serializable	 可避免脏读、不可重复读、虚读情况的发生。 **它要求所有的事务都被串行，不能并发的处理**
 - 可重复读  Repeatable read	 可避免脏读、不可重复读情况的发生。 
   (这个级别是Mysql的默认隔离级别，理论上这个级别不能避免幻读的问题，但是Mysql在这个级别上就成功的避免了脏读，不可重复读和幻读三种问题)
 - 授权读    Read committed	 可避免脏读情况发生。
 - 未授权读  Read uncommitted  最低级别，以上情况均无法保证。
 
事务中常出现的三种问题

 - 脏读：所谓的脏读，其实就是读到了别的事务回滚前的脏数据。
 - 不可重复读：在一个事务过程中，多次读取到的数据不一致。
 - 幻读：事务A首先根据条件索引得到N条数据，然后事务B改变了这N条数据之外的M条或者增添了M条符合事务A搜索条件的数据.
 - 更新丢失（Lost Update）：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务的存在，就会发生丢失更新问题

#### 事务的实现

事务隔离机制的实现基于锁机制和并发调度。其中并发调度使用的是MVVC（多版本并发控制），通过保存修改的旧版本信息来支持并发一致性读和回滚等特性。

按锁的粒度分类

    表级锁
    行级锁
    页级锁

按照锁的使用属性分类

    共享锁: 又叫做读锁。 当用户要进行数据的读取时，对数据加上共享锁。共享锁可以同时加上多个。允许其他线程读,但是不允许写
    排他锁: 又叫做写锁。 当用户要进行数据的写入时，对数据加上排他锁。排他锁只可以加一个，他和其他的排他锁，共享锁都相斥。

并发控制

    悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。在查询完数据的时候就把事务锁起来，直到提交事务。实现方式：使用数据库中的锁机制 乐观锁适用于写比较少的情况下（多读场景）
    乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。在修改数据的时候把事务锁起来，通过version的方式来进行锁定。实现方式：乐一般会使用版本号机制或CAS算法实现。 一般多写的场景下用悲观锁就比较合适
